{
  description = "emmabastas system configuration";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-22.05";
    home-manager = {
      url = "github:nix-community/home-manager/release-22.05";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    nix-doom-emacs.url = "github:nix-community/nix-doom-emacs";
  };

  outputs = { self, nixpkgs, home-manager, nix-doom-emacs, ... }:
  let
    system = "x86_64-linux";

    pkgs = import nixpkgs {
      inherit system;
      config = { allowUnfree = true; };
    };

    lib = nixpkgs.lib;

    allSame = with self.inputs.nixpkgs.lib; values:
      if tail values == []
        then true
      else if head values == head (tail values)
        then allSame (tail values)
      else false;

    join = with self.inputs.nixpkgs.lib; sep: values:
      if values == []
        then ""
      else if tail values == []
        then head values
      else "${head values}${sep}${join sep (tail values)}";

    # based off https://stackoverflow.com/a/54505212
    recursiveMerge = with self.inputs.nixpkgs.lib; attrList:
      let f = attrPath:
        zipAttrsWith (n: values:
          if tail values == []
            then head values
          else if all isList values
            then unique (concatLists values)
          else if all isAttrs values
            then f (attrPath ++ [n]) values
          else if allSame values
            then head values
          else abort "Values in ${join "." attrPath} can't be merged."
        );
      in f [] attrList;

    hardware-config = (
      # Do not modify this file!  It was generated by ‘nixos-generate-config’
      # and may be overwritten by future invocations.  Please make changes
      # to /etc/nixos/configuration.nix instead.
      { config, lib, pkgs, modulesPath, ... }:
      
      {
        imports =
          [ (modulesPath + "/installer/scan/not-detected.nix")
          ];
      
        boot.initrd.availableKernelModules = [ "xhci_pci" "ehci_pci" "ahci" "sd_mod" ];
        boot.initrd.kernelModules = [ ];
        boot.kernelModules = [ "kvm-intel" ];
        boot.extraModulePackages = [ ];
      
        fileSystems."/" =
          { device = "/dev/disk/by-uuid/a4ef7ef0-7ea6-46e4-8a5f-ec9cf5fe8f24";
            fsType = "ext4";
          };
      
        fileSystems."/boot" =
          { device = "/dev/disk/by-uuid/BFEA-950B";
            fsType = "vfat";
          };
      
        swapDevices =
          [ { device = "/dev/disk/by-uuid/04019ade-d0d4-40ff-a6f9-bf567ae3fce9"; }
          ];
      
        # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
        # (the default) this is the recommended approach. When using systemd-networkd it's
        # still possible to use this option, but it's recommended to use it in conjunction
        # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
        networking.useDHCP = lib.mkDefault true;
        # networking.interfaces.enp3s0.useDHCP = lib.mkDefault true;
        # networking.interfaces.wlp2s0.useDHCP = lib.mkDefault true;
      
        hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
        # high-resolution display
        hardware.video.hidpi.enable = lib.mkDefault true;
      }
      
    );
  in {
    nixosConfigurations = {
      nixos = lib.nixosSystem {
        inherit system;

        modules = [
          home-manager.nixosModules.home-manager {
            home-manager = {
              useGlobalPkgs = true;
              useUserPackages = true;
              users.emma = lib.mkMerge [
                nix-doom-emacs.hmModule
                (import ./emma)
              ];
            };
          }
          ({ config, pkgs, ... }: (recursiveMerge [
            {
              imports = [ hardware-config ];
            }
            {
              users.users.emma = {
                isNormalUser = true;
                extraGroups = [ "wheel" "networkmanager" ];
              };
            }
            {
              # Use the systemd-boot EFI boot loader.
              boot.loader.systemd-boot.enable = true;
              boot.loader.efi.canTouchEfiVariables = true;
            }
            {
              networking.networkmanager.enable = true;
            
              # The global useDHCP flag is deprecated, therefore explicitly set to false here.
              # Per-interface useDHCP will be mandatory in the future, so this generated config
              # replicates the default behaviour.
              networking.useDHCP = false;
              networking.interfaces.enp3s0.useDHCP = true;
              networking.interfaces.wlp2s0.useDHCP = true;
            
              # Open ports in the firewall.
              # networking.firewall.allowedTCPPorts = [ ... ];
              # networking.firewall.allowedUDPPorts = [ ... ];
              # Or disable the firewall altogether.
              networking.firewall.enable = false;
            }
            {
              i18n.defaultLocale = "en_US.UTF-8";
              console.keyMap = "sv-latin1";
              services.xserver.layout = "se";
              time.timeZone = "Europe/Stockholm";
            }
            {
              networking.hostName = "nixos";
            }
            {
              console = {
                earlySetup = true;
                font = "${pkgs.terminus_font}/share/consolefonts/ter-132n.psf.gz";
                packages = with pkgs; [ terminus_font ];
              };
            }
            {
              services.xserver = {
                videoDrivers = [ "modesetting" ];
                useGlamor = true;
                dpi = 220;
              };
            }
            {
              services.xserver = {
                desktopManager.xterm.enable = false;
            
                displayManager = {
                  defaultSession = "none+i3";
                };
            
                windowManager.i3 = {
                  enable = true;
                };
              };
            }
            {
              environment.systemPackages = [ pkgs.vim ];
            }
            {
              environment.systemPackages = [ pkgs.brightnessctl ];
            }
            {
              nixpkgs.config.allowUnfree = true;
              environment.systemPackages = [ pkgs.mathematica ];
            }
            {
              #nixpkgs.config.allowUnfree = true;
              #services.teamviewer.enable = true;
            }
            {
              sound.enable = true;
              hardware.pulseaudio.enable = true;
            }
            {
              services.xserver.libinput.enable = true;
            }
            {
              services.xserver = {
                enable = true;
                autorun = true;
              };
            }
            {
              services.openssh.enable = true;
            }
            
            {
              # This value determines the NixOS release from which the default
              # settings for stateful data, like file locations and database versions
              # on your system were taken. It‘s perfectly fine and recommended to leave
              # this value at the release version of the first install of this system.
              # Before changing this value read the documentation for this option
              # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
              system.stateVersion = "21.11"; # Did you read the comment?
            }
          ]))
        ];
      };
    };
  };
}
